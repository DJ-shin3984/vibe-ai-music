---
description: TypeScript, JavaScript — 타입 안전성, 모듈, 검증, 에러 처리
alwaysApply: false
---

# TypeScript & JavaScript — 타입스크립트·자바스크립트

프레임워크 무관 공통 규칙(TypeScript, JavaScript)입니다.

## TypeScript (프레임워크 무관)

### Type Safety Defaults (타입 안전성 기본)
- Assume `strict` TypeScript. Do not weaken compiler options to "make it work."
- Avoid `any`. Prefer `unknown` + narrowing, or generics with constraints.
- Use `as` casts only as a last resort; prefer real type guards and runtime checks.
- Prefer `satisfies` over `as` when validating object shapes without widening types.
- Prefer explicit return types for exported functions and public APIs.

### Modeling Patterns (모델링 패턴)
- Prefer discriminated unions over boolean flags or "stringly-typed" conditionals.
- Prefer `type` for unions/utility composition; use `interface` when you need declaration merging or an extensible object contract.
- Prefer `readonly` data where mutation isn't required; use `as const` for literal preservation.
- Avoid `enum` unless you specifically need emitted JS; prefer union literals (`'a' | 'b'`) or `as const` objects.

### Imports / Modules (임포트·모듈)
- Use `import type { ... }` for type-only imports to avoid runtime side effects and keep bundles clean.
- Keep ESM/CJS consistent with the repo. Don't mix patterns without a clear reason.
- Avoid implicit "barrel" imports that create cycles; prefer direct imports when boundaries matter.

### Error-Prone Areas (오류 취약 구간)
- Don't use `@ts-ignore` or `@ts-nocheck`. If absolutely unavoidable, use `@ts-expect-error` with a short reason.
- Don't rely on non-null assertions (`!`) unless you can prove the invariant locally.
- Avoid broad `catch (e)` assumptions. Treat caught values as `unknown` and normalize to an `Error`.

### Public Types & Boundaries (공개 타입·경계)
- For any boundary that touches external input (network, filesystem, env, user input), separate:
  - runtime parsing/validation (produces safe data)
  - typed domain logic (assumes validated data)
- Avoid leaking internal types across module boundaries. Export small, stable types.

### Code Hygiene (코드 위생)
- Prefer small, named helper types over deeply nested inline conditional types.
- Keep generics readable; if a type is hard to understand quickly, simplify it.

---

## JavaScript (프레임워크 무관)

### Language & Runtime Assumptions (언어·런타임 가정)
- Prefer modern JS (ES2020+). Use `async/await` over raw Promise chains unless it's genuinely clearer.
- Don't introduce transpilation/polyfills unless the repo already uses them and the target requires it.
- Keep module style consistent (ESM vs CJS). Do not mix without a concrete reason.

### Semantics & Footguns (의미·함정)
- Use `const` by default; use `let` only when reassignment is necessary; avoid `var`.
- Prefer strict equality (`===`, `!==`) unless you have a specific coercion need and document it.
- Avoid relying on truthiness for non-boolean values at boundaries; be explicit (`value != null`, `Array.isArray`, `typeof` checks).
- Avoid mutating inputs unless the function contract clearly says so; prefer returning new values.

### Data Handling & Validation (데이터 처리·검증)
- Treat all external input as untrusted; validate/normalize at the boundary before business logic.
- Prefer narrow "shape checks" (guards) at boundaries instead of assuming properties exist.
- When parsing JSON, assume it can be malformed or unexpected; handle failures explicitly.

### Errors & Control Flow (에러·제어 흐름)
- Prefer throwing `Error` (or subclasses) rather than strings/objects.
- Never silently ignore errors. If you intentionally suppress, leave a clear comment explaining why and what is safe.
- When catching, preserve causality if supported (e.g., include original error context).

### Style & Maintainability (스타일·유지보수성)
- Prefer small, single-purpose functions with clear names.
- Avoid clever one-liners when they reduce clarity; write the obvious code.
- Avoid "action at a distance": no hidden global state changes, no monkey patching.

### Imports / Dependencies (임포트·의존성)
- Prefer explicit imports to reduce hidden coupling.
- Avoid introducing new runtime dependencies unless asked; use built-in platform features first.

### Node vs Browser (Node vs 브라우저)
- Don't assume Node-only globals (`process`, `Buffer`) in code that might run in browsers.
- Don't assume browser APIs (`window`, `document`) in code that might run in Node.
- If a module must be environment-specific, make that explicit in naming and structure.
