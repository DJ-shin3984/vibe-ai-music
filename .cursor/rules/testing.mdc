---
description: 테스트(Testing, Jest, Vitest) — 목적, 격리, 모킹, 어설션
alwaysApply: false
---

# Testing — 테스트

테스트 작성·실행 규칙(공통, Jest, Vitest)입니다.

### 프로젝트 설정 (Vitest)
- **러너**: Vitest. `yarn test`(watch) / `yarn test:run`(단일 실행).
- **파일**: `**/*.test.{ts,tsx}`. 새 기능 추가 시 해당 모듈/컴포넌트 옆에 `*.test.ts(x)` 작성.
- **케이스**: 정상·예외·경계 조건을 구분해 작성.

## Testing (공통·프레임워크 무관 규칙)

### Purpose & Scope (목적·범위)
- Test behavior, not implementation details.
- Prefer fewer, higher-signal tests over lots of brittle tests.
- Optimize for determinism, speed, and clarity.

### Test Shape (테스트 형태)
- Use Arrange → Act → Assert (AAA) (or Given/When/Then) consistently.
- One primary assertion per test (multiple asserts ok if they verify the same behavior).
- Keep tests small; avoid multi-scenario "mega tests."

### Naming & Readability (이름·가독성)
- Name tests by behavior and outcome (what/when/then).
- Avoid vague names like "should work" or "handles errors."
- Keep the test body readable; avoid clever abstractions.

### Isolation & Determinism (격리·결정성)
- Do not depend on test order.
- Avoid shared mutable state across tests.
- Reset/cleanup state between tests; prefer per-test setup over global setup when possible.
- Eliminate flakiness:
  - no arbitrary sleeps
  - avoid time/clock dependence unless explicitly controlled/mocked
  - avoid network dependence unless explicitly an integration test

### Data & Fixtures (데이터·픽스처)
- Prefer inline test data when it's small and clarifies intent.
- Use factories/fixtures only when reuse improves clarity and reduces duplication.
- Keep fixtures minimal; avoid "kitchen sink" objects.

### Mocking (모킹) / Stubbing (모킹·스터빙)
- Mock at boundaries (I/O, network, filesystem, time, randomness), not in the middle of pure logic.
- Prefer fakes over deep mocks when feasible.
- Avoid mocking the thing you're trying to test.
- Assert on outputs/side effects, not internal call sequences (unless that's the behavior).

### Assertions (어설션)
- Assert the most important behavior first.
- Prefer specific assertions over broad snapshots or "truthy" checks.
- When failures happen, error messages should be obvious and actionable.

### Integration vs Unit (통합 vs 단위)
- Be explicit about test level:
  - unit tests: fast, isolated
  - integration tests: real components, limited scope
  - e2e tests: minimal count, highest signal, highest cost
- Use the smallest test level that gives confidence for the behavior.

### Reliability & Timing (신뢰성·타이밍)
- Prefer event-driven waiting (wait for condition) over fixed delays.
- Use timeouts intentionally; keep them as low as reliability allows.
- Run tests in parallel only if isolation is guaranteed.

### Environment & Secrets (환경·시크릿)
- Tests must not require real secrets.
- Use test env configs that are safe by default.
- Avoid writing to real user data or production resources.

### Failure Triage (실패 대응)
- If a test is flaky, fix or remove it—do not "just rerun."
- When adding tests, ensure they fail for the right reason and pass reliably.

### Performance (성능)
- Keep test suites fast; avoid expensive setup in every test.
- Prefer targeted integration/e2e coverage over exhaustive UI flows.

### Maintenance (유지보수)
- Update tests when behavior changes; do not "paper over" failures with weaker assertions.
- Avoid overcoupling to exact formatting/wording unless that is the intended contract.

---

## Jest (프레임워크별 규칙)

### Setup & Isolation (설정·격리)
- Prefer `beforeEach`/`afterEach` over `beforeAll`/`afterAll` unless setup is truly immutable.
- Use `jest.resetAllMocks()` / `jest.clearAllMocks()` consistently (match existing repo convention).
- Avoid relying on Jest's shared module cache; use `jest.resetModules()` only when you truly need a clean import graph.

### Mocking (모킹)
- Prefer `jest.mock()` at module boundaries; avoid deep mocking internal functions.
- Avoid hoist surprises: keep `jest.mock()` calls at the top-level (not inside tests) unless using `jest.doMock()` intentionally.
- Use `jest.spyOn()` for partial mocking; always restore spies when the suite expects isolation.

### Timers & Time (타이머·시간)
- Prefer real timers unless you are explicitly testing time-based behavior.
- If using fake timers:
  - keep usage localized to a describe block
  - advance time explicitly (`jest.advanceTimersByTime`, `runOnlyPendingTimers`)
  - restore real timers after (`jest.useRealTimers()`)

### Async Tests (비동기 테스트)
- Always `await` async work; avoid mixing `done` callbacks with async/await.
- Prefer `expect(...).resolves` / `expect(...).rejects` when it improves readability.

### Snapshots (스냅샷)
- Use snapshots sparingly and only for stable, intentional contracts.
- Avoid snapshotting huge objects or entire rendered trees when targeted assertions are clearer.
- When updating snapshots, confirm the change is intended—don't blindly accept.

### Module System Notes (모듈 시스템)
- Be consistent with ESM/CJS handling per project setup; don't introduce a new transform strategy.
- Avoid adding new Babel/Jest transformers unless explicitly requested.

### Performance (성능)
- Avoid expensive global setup in `setupFilesAfterEnv` unless it benefits most tests.
- Prefer targeted mocks in the test file over global mocks that affect unrelated suites.

---

## Vitest (프레임워크별 규칙)

### Setup & Isolation (설정·격리)
- Prefer `beforeEach`/`afterEach` over `beforeAll`/`afterAll` unless setup is truly immutable.
- Reset mocks consistently (match repo convention):
  - use `vi.clearAllMocks()` and/or `vi.resetAllMocks()` as appropriate
- Avoid relying on shared module state; use `vi.resetModules()` only when a fresh import graph is required.

### Mocking (모킹)
- Prefer `vi.mock()` at module boundaries; avoid deep mocking internal functions.
- Be mindful of mock hoisting: define `vi.mock()` at the top-level unless intentionally using dynamic mocking.
- Prefer `vi.spyOn()` for partial mocks; restore spies when needed for isolation.

### Timers & Time (타이머·시간)
- Use real timers by default.
- If using fake timers:
  - keep usage localized
  - advance time explicitly (`vi.advanceTimersByTime`, `vi.runOnlyPendingTimers`)
  - restore real timers after (`vi.useRealTimers()`)

### Async Tests (비동기 테스트)
- Always `await` async work; avoid callback-style `done`.
- Prefer `expect(...).resolves` / `expect(...).rejects` when it reads better.

### Snapshots (스냅샷)
- Use snapshots sparingly for stable contracts.
- Avoid snapshotting large structures when targeted assertions are clearer.
- Review snapshot updates intentionally.

### ESM / Tooling Alignment (ESM·도구 정렬)
- Lean into the project's Vite/ESM setup; avoid introducing Jest-like transform complexity.
- Avoid adding new Vite plugins/test environment changes unless explicitly requested.

### Performance (성능)
- Prefer per-file mocks over global test setup that impacts unrelated suites.
- Use `describe` scoping to keep heavy setup localized.
